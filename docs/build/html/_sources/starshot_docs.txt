
=============================
Starshot module documentation
=============================

Overview
========

.. automodule:: pylinac.starshot

Running the Demo
================

To run the Starshot demo, run starshot.py, or create a script and run::

    from pylinac import Starshot
    Starshot().run_demo()

Results will be printed to the console and a figure showing the analyzed starshot image will pop up.
#TODO: show screenshots of demo

Image Acquisition
=================

To capture starshot images, film is often used, but superimposed EPID images can also work for collimator measurements.
See #TODO: fill in literature of starshots

Typical Use
===========

The Starshot analysis follows methods from what is specified in Jorgensen et al. and assumes your tests will run the exact same way. Let us assume
you've made a VMAT object as follows::

    from pylinac import Starshot
    mystar = Starshot()

The minimum needed to get going is to:

* **Load images** -- Loading film or superimposed EPID DICOM images into your Starshot class object can be done by
  passing the file path or by using a UI to find and get the file. The code might look like either of the following::

    # set the file path
    star_img = "C:/QA Folder/stars/gantry_starshot.tif"
    # load the images from the file path
    mystar.load_image(star_img)

    # *OR*
    # Identify the image using a UI
    mystar.load_image_UI()

* **Analyze the images** -- After loading the image, all that needs to be done is analyze the image with a few
  settings passed in::

    # analyze!
    mystar.analyze(allow_inversion=True, radius=50)

* **View the results** -- VMAT can print out the summary of results to the console as well as draw a matplotlib image to show where the
  ROIs were taken and their values::

      # print results to the console
      print(myvmat.get_string_results())
      # view analyzed images
      myvmat.show_img_results()

For future reference, you can actually set the test and tolerance as arguments to the analyze method for even shorter code.

Algorithm
=========

**Allowances**

* The image can be either inversion
* The image can be any size

**Restrictions**

* The center of the "star" must be near an edge of the image.
* If using superimposed images, the images must be the same size.
* The radiation spokes must extend to both sides of the center. I.e. the spokes must not end at the center of the circle.
* The spokes must have an adjacent spacing of at least 3 degrees.

**Pre-Analysis**

* *Check image inversion* -- The image is checked for proper inversion by summing the image along each axis and then
  finding the point of maximum value. If the point is not in the central 1/3 of the image, it is thought to be inverted.
  This check can be skipped but is enabled by default.
* *Set mechanical isocenter* -- Unless the user has manually set the pixel location of the mechanical isocenter (the
  starting point of the algorithm) it is automatically found by summing the image along each axis and finding the
  center of the full-width, 80%-max of each sum.

**Analysis**

* *Extract circle profile* -- A circular profile is extracted from the image centered around the mechanical isocenter
  and at the radius given.
* *Find spoke centers* -- The circle profile is analyzed for peaks. Once the peaks are found, the pixels around the peak
  are reanalyzed to find the center of the full-width, half-max. An even number of spokes must be found (1 for each
  side. E.g. 3 collimator angles should produce 6 spokes, one for each side of the CAX).
* *Match peaks* -- Peaks are matched to their counterparts opposite the CAX to compose a line.
* *Find wobble* -- Starting at the mechanical isocenter point, an evolutionary gradient method is utilized like this:
  for a 3x3 matrix around a starting point, the sum of distances to each line is calculated. If the center matrix value
  is not the lowest value (within a tolerance), the calculation is performed again, starting at the point of lowest value of the previous
  calculation. Thusly, the algorithm moves 1 pixel at a time toward a point of minimum distance to all lines. Once the
  nearest pixel is found, the algorithm switches to sub-pixel precision and repeats.

**Post-Analysis**

* *Check if passed* -- Once the wobble is calculated, it is tested against the tolerance given, and passes if below the
  tolerance.

API Documentation
=================

.. autoclass:: pylinac.starshot.starshot.Starshot
    :members:
